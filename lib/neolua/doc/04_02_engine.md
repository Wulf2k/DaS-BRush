# Script engine

The `Lua` class holds all together, that is needed for the compile and the runtime process. Normally you need only one instance per 
application. But sometimes it is useful to have more than one e.g. multithread scenarios.

Main task for `Lua` are:
* Compiling scripts to chunks
* Cache dynamic binding rules, they resolved during runtime
* Language runtime methods
* Reflection cache during parsing

## `CompileChunk(...)`

Compiles a script to a chunk.

This method is very useful, if you want to execute a chunk more than one times.

| Argument | Description |
|:---------|:------------|
| `sFileName`, `sCode`, `sName`, `tr` | Defines the script code and the name. |
| `debug` | It is possible to manipulate the chunk creation to inject debug functionality. `null` creates plan chunks without any debugging functionality. |
| `args`  | Defines arguments for the chunk. So it is possible define arguments for the chunk. A chunk that is compiled with `CompileChunk` has at least one argument `G`, the global environment. |

see [Chunks](04_03_chunk.md)

## `LuaGlobal CreateEnvironment`

Creates a new LuaTable, that is associated to the lua script engine and acts as a standard lua environment.

It is also possible to create the enviroment from the `LuaGlobal` constructor, but best practice is to do it over this method.

see [Tables](04_04_table.md)

## `CreateLambda(...)`

Creates a delegate of lua code without any overhead.

A delegate, that is generated by this function has no debug information and no environment. *It is not possible* to use global variables or lua function/libraries in the code. Only the clr-Library is useable.

```C#
using (Lua l = new Lua())
{
  // Creates the delegate
  // the x is optional, if it not given, than the name comes from the delegate-parameter
  var f = l.CreateLambda<Func<double, double>>("f", "return clr.System.Math:Abs(x) * 2", "x");
  Console.WriteLine("f({0}) = {1}", 2, f(2));
  Console.WriteLine("f({0}) = {1}", 2, f(-2));
  
  // Creates a delegate with a declaration
  // it is possible to set a delegate type (replace the null with the type)
  // it is also possible to declare local variables/functions 
  var f2 = l.CreateLambda("f2", "local Math = clr.System.Math; return Math:Abs(x) * 2;", null, typeof(double), new KeyValuePair<string, Type>("x", typeof(double)));
  Console.WriteLine("f2({0}) = {1}", 2, f2.DynamicInvoke(2));
  Console.WriteLine("f2({0}) = {1}", 2, f2.DynamicInvoke(-2));
}
```

This is a very useful if you need small code blocks, like formulas or simple expressions.

## `DefaultDebugEngine`

Singleton for the a debug engine, that compiles the script in a dynamic assembly with debug information. So, it is possible to retrieve a stack trace from every exception.
The runtime overhead is very low. But on the other hand it consumes a lot memory and the code is not collectable from the garbage collector.

To have more influence over the memory you have to create a own instance of `LuaStackTraceDebugger`. If this class is collected, all chunks they are associated to debug engine
are also collected.

The stack trace is added to the Data property of every exception. To retrieve a formatted stack trace use  `LuaExceptionData.GetData`.

```C#
LuaExceptionDataled = LuaExceptionData.GetData(e);
Console.Write(led.StackTrace); 
```

## `FloatType`, `IntegerType`

These two properties define the default data type for numbers.

## `ParseNumber`

Parses a number like `tonumber`.

## `StandardPackagesPaths`, `StandardPackagesPath`

The global package search paths. As an array or a `;` seperated list.

## `Version`

Returns the current version of NeoLua.

## `void Clear()`

Clears the dynamic binding rules.

## `void DumpRuleCaches(...)`

Dumps all cached rules of this script engine. This method is only for debug proposes and might be removed in later version.